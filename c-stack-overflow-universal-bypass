-- this will not bypass non-C stack overflow checks (citadel anticheat hint hint), just to be specific!!!!!

getgenv().IsHookingSafe = false

local _cache = {}
local info = getrenv().debug.info

local print, warn, error = getrenv().print, getrenv().warn, getrenv().error;

local namecall, index, newindex; -- if these result in different errors your executor should not exist
xpcall(function() return game:_() end, function() namecall = info(2,"f") end)
xpcall(function() return game[nil] end, function() index = info(2,"f") end)
xpcall(function() game[nil] = nil end, function() newindex = info(2,"f") end)

local function checkincache(func)
    for i, v in pairs(_cache) do
        if v[1] == func then
            return v
        end
    end

    return nil
end

local function insertincache(func, ofunc)
    table.insert(_cache, {func, 1, {ofunc == namecall, ofunc == index, ofunc == newindex}, ofunc})
    local ins = _cache[#_cache]

    task.spawn(function() -- manual gc process
        repeat task.wait(.5) until ins[5] -- when newfunc is called this will turn true
        task.wait(.5)
        if not getgenv().IsHookingSafe then
            getgenv().IsHookingSafe = true
        end

        table.remove(_cache, table.find(_cache, ins))
    end)
end

local h; h = hookfunction(getrenv().coroutine.wrap, function(...)
    local fnc1 = ...

    if not checkcaller() and type(fnc1) == "function" then
        local cachevalue = checkincache(fnc1)
        if cachevalue and cachevalue[1] == fnc1 then
            if (cachevalue[2] > 194 and cachevalue[2] < 199) then
                local newfunc; newfunc = newcclosure(function(...)
                    if cachevalue[2] > 198 then cachevalue[5] = true return error("C stack overflow", 2) end -- safe/double check

                    if cachevalue[3] then
                        local bools = cachevalue[3]

                        if bools[1] then
                            cachevalue[5] = true

                            if pcall(h(namecall), ...) then return select(2, pcall(h(namecall), ...)) end
                            error(select(2, pcall(h(namecall), ...)), 2)
                        elseif bools[2] then
                            cachevalue[5] = true

                            if pcall(h(index), ...) then return select(2, pcall(h(index), ...)) end
                            error(select(2, pcall(h(index), ...)), 2)
                        elseif bools[3] then
                            cachevalue[5] = true

                            if pcall(h(newindex), ...) then return select(2, pcall(h(newindex), ...)) end
                            error(select(2, pcall(h(newindex), ...)), 2)
                        elseif type(cachevalue[4]) == "function" and debug.info(cachevalue[4], "n") ~= "" then -- func is a C function (gcinfo, assert, etc.)
                            cachevalue[5] = true

                            local orig = cachevalue[4]
                            if pcall(h(orig), ...) then return select(2, pcall(h(orig), ...)) end
                            error(select(2, pcall(h(orig), ...)), 2)
                        else
                            cachevalue[5] = true

                            return fnc1(...) -- default
                        end
                    end
                end)

                cachevalue[1] = newfunc
                cachevalue[2] += 1
                
                return newfunc
            end

            local res = h(...)
            cachevalue[1] = res
            cachevalue[2] += 1

            return res
        else
            local res = h(...)
            insertincache(res, fnc1)
            
            return res
        end
    end

    return h(...)
end)
