-- C stack overflow bypass by @__europa
-- thanks to unlimited, xnx, kar and ludi for helping with detections

getgenv().IsHookingSafe = false
local _cache;

task.spawn(function()
    task.spawn(function()
        task.wait(5)
        getgenv().IsHookingSafe = true
    end)

    repeat task.wait(.1) until _cache and #_cache ~= 0
    getgenv().IsHookingSafe = true
end)

_cache = {}
local info = getrenv().debug.info

local print, warn, error = getrenv().print, getrenv().warn, getrenv().error;

local namecall, index, newindex; -- if these result in different errors your executor should not exist
xpcall(function() return game:_() end, function() namecall = info(2,"f") end)
xpcall(function() return game[nil] end, function() index = info(2,"f") end)
xpcall(function() game[nil] = nil end, function() newindex = info(2,"f") end)

local h;

local function checkincache(func)
    for i, v in pairs(_cache) do
        if v[1] == tostring(func) then
            return v
        end
    end

    return nil
end

local function insertincache(func, ofunc)
    local thetbl; thetbl = {tostring(func), 1, {ofunc == namecall, ofunc == index, ofunc == newindex}, {
            ["f"] = ofunc,
            ["n"] = debug.info(ofunc, "n")
        },
        (function(...) -- replacement function
            local cachevalue = thetbl;
            
            pcall(coroutine.wrap(ofunc))
            local bigerr = select(2, pcall(coroutine.wrap(ofunc)))

            -- safe check (end all be all)
            if cachevalue[2] > 198 and bigerr ~= "cannot resume dead coroutine" then
                cachevalue[6] = true

                return error("C stack overflow", 2)
            end

            -- safe check 2 (end all be all)
            if bigerr == "cannot resume dead coroutine" then
                return error("cannot resume dead coroutine", 2)
            end

            if cachevalue[3] then
                local bools = cachevalue[3]

                if cachevalue[4] and cachevalue[4]["f"] then
                    cachevalue[6] = true

                    local orig = cachevalue[4]["f"]

                    if pcall(h(orig), ...) then return select(2, pcall(h(orig), ...)) end
                    error(select(2, pcall(h(orig), ...)), 2)
                else
                    cachevalue[6] = true
                    local __args = {pcall(ofunc, ...)}

                    if __args[1] then return select(2, unpack(__args)) end
                    return error(select(2, unpack(__args)), 2)
                end
            end
        end),
        false
    }

    table.insert(_cache, thetbl)
    task.spawn(function() -- manual gc process
        repeat task.wait() until thetbl[6] -- when newfunc is called this will turn true

        table.remove(_cache, table.find(_cache, thetbl))
    end)
end

-- the actual hook
h = hookfunction(getrenv().coroutine.wrap, function(...)
    local fnc1 = ...

    if not checkcaller() and type(fnc1) == "function" then
        local cachevalue = checkincache(fnc1)
        if cachevalue then
            if cachevalue[6] then return h(...) end

            if (cachevalue[2] > 194 and cachevalue[2] < 199) then
                local newfunc = h(cachevalue[5]) -- wrap the other function !!!

                cachevalue[1] = tostring(newfunc)
                cachevalue[2] += 1
                cachevalue[5] = newfunc
                
                return newfunc
            end

            local res = h(...)
            cachevalue[1] = tostring(res)
            cachevalue[2] += 1

            return res
        else
            local res = h(...)
            insertincache(res, fnc1)
            
            return res
        end
    end

    return h(...)
end)
