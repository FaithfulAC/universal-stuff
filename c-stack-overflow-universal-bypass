-- C stack overflow bypass by @__europa
-- thanks to unlimited, xnx, ka(x)r and ESPECIALLY ludi for helping with detections

getgenv().IsHookingSafe = false
local _cache;

task.spawn(function()
    task.spawn(function()
        task.wait(5)
        getgenv().IsHookingSafe = true
    end)

    repeat task.wait(.1) until _cache and #_cache ~= 0
    getgenv().IsHookingSafe = true
end)

_cache = {}
local info = getrenv().debug.info

local print, warn, error = getrenv().print, getrenv().warn, getrenv().error;
local h;

local function checkincache(func)
    for i, v in pairs(_cache) do
        if v[1] == tostring(func) then
            return v
        end
    end

    return nil
end

local function insertincache(func, ofunc)
    local thetbl; thetbl = {
        tostring(func), -- for comparison
        1, -- for intervals of being wrapped
        (function(...) -- replacement function (to be wrapped)
            local cachevalue = thetbl;

            pcall((h or coroutine.wrap)(ofunc))

            local bigerr = select(2, pcall((h or coroutine.wrap)(func)))
            local bigerr2 = select(2, pcall((h or coroutine.wrap)(ofunc)))

            -- safe check (end all be all)
            if (bigerr ~= "cannot resume dead coroutine" and cachevalue[2] > 198) or bigerr == "C stack overflow" then
                cachevalue[4] = true

                return error("C stack overflow", 2)
            elseif bigerr == "cannot resume dead coroutine" then
                return error("cannot resume dead coroutine", 2)
            end

            cachevalue[4] = true

            if pcall((h or coroutine.wrap)(ofunc), ...) then return select(2, pcall((h or coroutine.wrap)(ofunc), ...)) end
            error(select(2, pcall((h or coroutine.wrap)(ofunc), ...)), 2)
        end),
        false, -- was function called? gc process below requires this
        nil
    }

    table.insert(_cache, thetbl)
    task.spawn(function() -- manual gc process
        repeat task.wait() until thetbl[4] -- when newfunc is called this will turn true

        table.remove(_cache, table.find(_cache, thetbl))
    end)
end

-- the actual hook
h = hookfunction(getrenv().coroutine.wrap, function(...)
    local fnc1 = ...

    if not checkcaller() and type(fnc1) == "function" then
        local cachevalue = checkincache(fnc1)
        if cachevalue then
            if (cachevalue[2] > 194 and cachevalue[2] < 199) then
                local newfunc = h(cachevalue[3]) -- wrap the other function !!!

                cachevalue[1] = tostring(newfunc)
                cachevalue[2] += 1
                cachevalue[3] = newfunc
                
                return newfunc
            end

            local res = h(...)
            cachevalue[1] = tostring(res)
            cachevalue[2] += 1

            return res
        else
            local res = h(...)
            insertincache(res, fnc1)
            
            return res
        end
    end

    return h(...)
end)

--[[task.wait(2)

local hook1; hook1 = hookmetamethod(game,"__namecall", function(...)
    return hook1(...)
end)
local hook2; hook2 = hookmetamethod(game,"__index", function(...)
    return hook2(...)
end)
local hook3; hook3 = hookmetamethod(game,"__newindex", function(...)
    return hook3(...)
end)

warn("Hooks loaded")]]
