-- C stack overflow bypass by @__europa
-- thanks to unlimited, xnx, ka(x)r and ESPECIALLY ludi for helping with detections

local _cache = {}

local info, print, warn, error = getrenv().debug.info, getrenv().print, getrenv().warn, getrenv().error;
local h;

local function checkincache(func)
    for i, v in pairs(_cache) do
        if v[1] == tostring(func) then
            return v
        end
    end
    return nil
end

local function insertincache(func, ofunc)
    local thetbl; thetbl = {
        tostring(func), -- for comparison
        1, -- for intervals of being wrapped
        (function(...) -- replacement function (to be wrapped)
            local cachevalue = thetbl;
            pcall((h or coroutine.wrap)(ofunc)) -- for good measure
            warn("Function was called")

            local __args = {pcall((h or coroutine.wrap)(ofunc), ...)}
            for i, v in pairs(__args) do warn(i,v) end

            local bigerr = __args[2]

            -- safe check (end all be all)
            if (bigerr ~= "cannot resume dead coroutine" and cachevalue[2] > 198) then
                cachevalue[4] = true

                warn(">198 and is not dead cor catcher")

                return error("C stack overflow", 2)
            elseif bigerr == "cannot resume dead coroutine" then
                warn("Dead cor caught, returning the error...")

                return error("cannot resume dead coroutine", 2)
            end
            cachevalue[4] = true

            if __args[1] then warn("Success, returning selected 2, objects") return select(2, unpack(__args)) end
            warn("Errored, returning selected 2, errors")

            if select(2, pcall((h or coroutine.wrap)(func))) == "cannot resume dead coroutine" then
                task.spawn(error, "First resulted function -> cannot resume dead coroutine; potential detection vector found?")
            end

            error(select(2, unpack(__args)), 2)
        end),
        false -- was function called? gc process below requires this
    }

    table.insert(_cache, thetbl)
    task.spawn(function() -- manual gc process
        repeat task.wait() until thetbl[4] -- when newfunc is called this will turn true

        table.remove(_cache, table.find(_cache, thetbl))
    end)
end

-- the actual hook
h = hookfunction(getrenv().coroutine.wrap, function(...)
    local fnc1 = ...

    if not checkcaller() and type(fnc1) == "function" then
        local cachevalue = checkincache(fnc1)
        if cachevalue then
            if cachevalue[4] then
                warn(cachevalue[4], "is true, therefore this already ran")
            end
            if (cachevalue[2] > 194 and cachevalue[2] < 199) then
                local newfunc = h(cachevalue[3]) -- wrap the other function !!!

                warn("Wrapped function in cache:", newfunc)

                cachevalue[1] = tostring(newfunc)
                cachevalue[2] += 1
                cachevalue[3] = newfunc
                
                return newfunc
            end

            local res = h(...)
            cachevalue[1] = tostring(res)
            cachevalue[2] += 1

            return res
        else
            local res = h(...)
            insertincache(res, fnc1)
            
            return res
        end
    end

    return h(...)
end)

task.wait(2)
getgenv().IsHookingSafe = true

local hook1; hook1 = hookmetamethod(game,"__namecall", function(...)
    return hook1(...)
end)
local hook2; hook2 = hookmetamethod(game,"__index", function(...)
    return hook2(...)
end)
local hook3; hook3 = hookmetamethod(game,"__newindex", function(...)
    return hook3(...)
end)
warn("Hooks loaded")
